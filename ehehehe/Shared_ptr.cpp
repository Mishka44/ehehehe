#include <iostream>
#include<memory>

// умные указатели
// 
void ex() {
	std::auto_ptr<int> aptr; // рекомендуется не применять
	//хранит выделенную область памяти, при выходе из зоны действия - освобождает память
	// не имеет конструктора копирования

	std::shared_ptr<int> shptr;
	// хранит в разных указателях указатель на какой-то общий элемент
	// контролирует количество копий указателя
	// освобождает память, когда все указатели на тот же объект уничтожены
	std::unique_ptr<int> uptr;
	// гарантирует уникальность одного адерса объекта(скопировать такой указатель нельзя) 
	// отсутствует конструктор копирования
	std::weak_ptr<int>wptr;
	// служебная дрянь для передачи адресов между общими указателями. Не повышает счётчик ссылок на объект


	// не владеющие <-указатели-> владеющие 
}

struct Data {
	int id;
	int matrix[1000][5];
};
void Print(std::unique_ptr<Data> &obj){
	obj->id;
	obj->matrix;
}

void ptr_ex() {
	//Data obj;
	Data* p_law = new Data;
	std::unique_ptr<Data> p_uniq = std::make_unique<Data>();
	// в make_unique можно принимать любые наборы данных, под которые есть конструктору у типа шаблона
	//
	Print(p_uniq);//передача p_uniq по параметру невозможна, так как нет конструктора копирования 
	// передача по ссылке правил работы такого указателя не нарушает
	auto p_shrd = std::make_shared<Data>();
	

}

template <typename Type>
class smart_pointer {
public:
	Type& operator*() {
		return *data;
	}
	const Type& operator*() const{
		return *data;
	}

private:
	Type* data_;
};